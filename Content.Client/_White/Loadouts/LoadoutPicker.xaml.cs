using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Content.Client._White.DatumContainer;
using Content.Shared.CCVar;
using Content.Shared.Clothing.Loadouts.Prototypes;
using Content.Shared.Clothing.Loadouts.Systems;
using Content.Shared.Customization.Systems;
using Content.Shared.Mind;
using Content.Shared.Preferences;
using Content.Shared.Roles;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.ContentPack;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;


namespace Content.Client._White.Loadouts;


[GenerateTypedNameReferences]
public sealed partial class LoadoutPicker : Control
{
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    [Dependency] private readonly IConfigurationManager _configManager = default!;

    private readonly Dictionary<string, Loadout> _selectedLoadouts = [];
    private readonly List<LoadoutEntry> _loadoutEntries = new();

    private readonly LocalDatumContainer<string> _customColorTints;
    private readonly LocalDatumContainer<bool> _customHeirloom;
    private readonly LocalDatumContainer<string> _customName;
    private readonly LocalDatumContainer<string> _customDescription;
    private readonly LocalDatumContainer<string> _customContent;

    public Action<List<Loadout>>? OnLoadoutsChanged;

    private int MaxLoadoutPoints => _configManager.GetCVar(CCVars.GameLoadoutsPoints);

    private int _loadoutPoints = 0;

    public CharacterRequirementsArgs CharacterRequirementsArgs = default!;

    public int LoadoutPoint
    {
        get => _loadoutPoints;

        set
        {
            LoadoutPoints.Text = Loc.GetString("marking-points-remaining", ("points", value));
            _loadoutPoints = value;
        }
    }

    public LoadoutPicker()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _customName = new("custom_name");
        _customDescription = new("custom_description");
        _customContent = new("custom_content");
        _customHeirloom = new("custom_heirloom");
        _customColorTints = new("custom_color_tints");

        SaveButton.OnPressed += SaveButtonPressed;
        SpecialColorTintToggle.OnPressed += SpecialColorTintTogglePressed;
    }

    public void SetData(IEnumerable<Loadout> selectedPreferenceList, CharacterRequirementsArgs characterRequirements)
    {
        ClearLoadouts();

        CharacterRequirementsArgs = characterRequirements;

        foreach (var preference in selectedPreferenceList)
        {
            if(!TryAddLoadout(preference.LoadoutName, out var loadout))
                continue;

            loadout.CustomColorTint = preference.CustomColorTint;
            loadout.CustomHeirloom = preference.CustomHeirloom;
            loadout.CustomName = preference.CustomName;
            loadout.CustomDescription = preference.CustomDescription;
            loadout.CustomContent = preference.CustomContent;
        }
    }

    public bool TryAddLoadout(ProtoId<LoadoutPrototype> loadoutPrototype, [NotNullWhen(true)] out Loadout? loadout)
    {
        if (_selectedLoadouts.TryGetValue(loadoutPrototype.Id, out loadout))
            return true;

        loadout = new(loadoutPrototype);

        return TryAddLoadout(loadout);
    }

    private bool TryAddLoadout(Loadout loadout)
    {
        ProtoId<LoadoutPrototype> loadoutPrototype = loadout.LoadoutName;

        if (!_prototypeManager.TryIndex(loadoutPrototype, out var prototype))
        {
            Logger.Debug("F1");
            return false;
        }

        if(prototype.Cost > LoadoutPoint)
        {
            Logger.Debug("F2");
            return false;
        }

        foreach (var requirement in prototype.Requirements)
        {
            if (!CharacterRequirementsArgs.IsValid(requirement, prototype, out var a))
            {
                Logger.Debug("F3 " + a);
                return false;
            }
        }

        if(prototype.CanBeHeirloom && _customHeirloom.TryGetValue(loadoutPrototype.Id, out var customHeirloom))
            loadout.CustomHeirloom = customHeirloom;
        if(prototype.CustomContent && _customContent.TryGetValue(loadoutPrototype.Id, out var customContent))
            loadout.CustomContent = customContent;
        if(prototype.CustomName && _customName.TryGetValue(loadoutPrototype.Id, out var customName))
            loadout.CustomName = customName;
        if(prototype.CustomDescription && _customDescription.TryGetValue(loadoutPrototype.Id, out var customDescription))
            loadout.CustomDescription = customDescription;

        LoadoutPoint -= prototype.Cost;
        _selectedLoadouts.Add(loadoutPrototype, loadout);
        return true;
    }

    public bool LoadCategoryButtons(ProtoId<LoadoutCategoryPrototype> loadoutCategoryPrototype)
    {
        ClearLoadoutCategoryButtons();
        Logger.Debug(_selectedLoadouts.Count + "<<<");
        var loadoutPrototypes = GroupLoadoutsByGroup(loadoutCategoryPrototype).ToList();
        if (loadoutPrototypes.Count == 0)
            return false;

        foreach (var loadoutPrototype in loadoutPrototypes)
        {
            var loadoutEntry = new LoadoutEntry();

            if(_selectedLoadouts.TryGetValue(loadoutPrototype.ID, out var loadout))
            {
                loadoutEntry.SetLoadout(loadout);
                loadoutEntry.Selected = true;
            }
            else
                loadoutEntry.SetLoadout(loadoutPrototype.ID);

            loadoutEntry.OnEditLoadoutRequired += OnEntryEditLoadoutRequired;
            loadoutEntry.OnLoadoutDirty += OnEntryLoadoutDirty;
            loadoutEntry.EnsureIsWearable(CharacterRequirementsArgs, LoadoutPoint);

            _loadoutEntries.Add(loadoutEntry);
            SortAndPasteEntries();
        }

        return true;
    }

    private void Dirty()
    {
        foreach (var entry in _loadoutEntries)
        {
            entry.EnsureIsWearable(CharacterRequirementsArgs, LoadoutPoint);
        }
        OnLoadoutsChanged?.Invoke(_selectedLoadouts.Select(x => x.Value).ToList());
    }

    private void SpecialColorTintTogglePressed(BaseButton.ButtonEventArgs obj)
    {
        if(_currPrototype == null || !_currPrototype.CustomColorTint)
            return;

        ColorEdit.Visible = SpecialColorTintToggle.Pressed;
    }

    private void OnEntryLoadoutDirty(LoadoutEntry obj)
    {
        Logger.Debug("SELECT " + obj.Loadout.LoadoutName + " " + _selectedLoadouts.ContainsKey(obj.Loadout.LoadoutName));
        if (TryFreeLoadout(obj.Loadout))
        {
            obj.Selected = false;
            LoadoutConfigContainer.Visible = false;
            Dirty();
            return;
        }

        obj.Selected = TryAddLoadout(obj.Loadout);
        Dirty();
    }

    private bool TryFreeLoadout(Loadout loadout)
    {
        if (!_selectedLoadouts.Remove(loadout.LoadoutName, out _))
            return false;

        if(_prototypeManager.TryIndex<LoadoutPrototype>(loadout.LoadoutName, out var prototype))
            LoadoutPoint += prototype.Cost;

        return true;
    }

    private void OnEntryEditLoadoutRequired(LoadoutEntry entry)
    {
        EditLoadout(entry);
    }

    private LoadoutPrototype? _currPrototype;
    private LoadoutEntry? _currEdit;

    public void EditLoadout(LoadoutEntry loadoutEntry)
    {
        var loadout = loadoutEntry.Loadout;
        if (!_prototypeManager.TryIndex<LoadoutPrototype>(loadout.LoadoutName, out var loadoutPrototype))
        {
            Logger.Error($"Unable to load loadout: unknown prototype {loadout.LoadoutName}");
            ClearupEdit();
            return;
        }

        LoadoutConfigContainer.Visible = true;

        SpecialName.Visible = loadoutPrototype.CustomName;
        SpecialDescription.Visible = loadoutPrototype.CustomDescription;
        SpecialBookText.Visible = loadoutPrototype.CustomContent;
        SpecialColorTintToggle.Visible = loadoutPrototype.CustomColorTint;

        if (loadoutPrototype.CustomName)
            NameEdit.Text = loadout.CustomName ?? "";

        if (loadoutPrototype.CustomDescription)
            DescriptionEdit.TextRope = new Rope.Leaf(loadout.CustomDescription ?? "");;

        if(loadoutPrototype.CustomContent)
            BookTextEdit.TextRope = new Rope.Leaf(loadout.CustomContent ?? "");

        if (loadoutPrototype.CustomColorTint )
        {
            if(loadout.CustomColorTint is not null)
            {
                SpecialColorTintToggle.Pressed = true;
                ColorEdit.Color = Color.FromHex(loadout.CustomColorTint);
                ColorEdit.Visible = true;
            }
            else
            {
                SpecialColorTintToggle.Pressed = false;
                ColorEdit.Visible = false;
            }
        }

        _currEdit = loadoutEntry;
        _currPrototype = loadoutPrototype;
    }

    private void ClearLoadoutCategoryButtons()
    {
        foreach (var entry in _loadoutEntries)
        {
            entry.OnEditLoadoutRequired -= OnEntryEditLoadoutRequired;
            entry.OnLoadoutDirty -= OnEntryLoadoutDirty;
        }

        _loadoutEntries.Clear();
        Loadouts.Children.Clear();
    }

    private void SortAndPasteEntries()
    {
        Loadouts.Children.Clear();
        _loadoutEntries.Sort();
        foreach (var entry in _loadoutEntries)
        {
            Loadouts.Children.Add(entry);
        }
    }

    private void SaveButtonPressed(BaseButton.ButtonEventArgs obj)
    {
        if(_currEdit == null)
            return;

        var oldValue = _currEdit.Loadout;
        oldValue.CustomName = TextOrNull(NameEdit.Text);
        oldValue.CustomContent = TextOrNull(BookTextEdit.TextRope);
        oldValue.CustomDescription = TextOrNull(DescriptionEdit.TextRope);
        oldValue.CustomColorTint = SpecialColorTintToggle.Pressed ? ColorEdit.Color.ToHex() : null;

        _currEdit.SetLoadout(oldValue);

        if(oldValue.CustomName != null) _customName.SetValue(oldValue.LoadoutName, oldValue.CustomName);
        else _customName.RemoveValue(oldValue.LoadoutName);
        if(oldValue.CustomContent != null) _customContent.SetValue(oldValue.LoadoutName, oldValue.CustomContent);
        else _customContent.RemoveValue(oldValue.LoadoutName);
        if(oldValue.CustomDescription != null) _customDescription.SetValue(oldValue.LoadoutName, oldValue.CustomDescription);
        else _customDescription.RemoveValue(oldValue.LoadoutName);
        if(oldValue.CustomColorTint != null) _customColorTints.SetValue(oldValue.LoadoutName, oldValue.CustomColorTint);
        else _customColorTints.RemoveValue(oldValue.LoadoutName);

        ClearupEdit();
        Dirty();
    }

    private void ClearupEdit()
    {
        LoadoutConfigContainer.Visible = false;
        _currEdit = null;
        _currPrototype = null;
    }

    private string? TextOrNull(Rope.Node node)
    {
        if(node is not Rope.Leaf leafNode)
            return null;
        return leafNode.Text;
    }

    private string? TextOrNull(string text)
    {
        if (string.IsNullOrEmpty(text))
            return null;

        return text;
    }

    private void ClearLoadouts()
    {
        ClearLoadoutCategoryButtons();
        _selectedLoadouts.Clear();
        LoadoutPoint = MaxLoadoutPoints;
    }

    private IEnumerable<LoadoutPrototype> GroupLoadoutsByGroup(ProtoId<LoadoutCategoryPrototype> loadoutCategoryPrototype)
    {
        foreach (var loadoutPrototype in _prototypeManager.EnumeratePrototypes<LoadoutPrototype>())
        {
            if(loadoutPrototype.Category == loadoutCategoryPrototype)
                yield return loadoutPrototype;
        }
    }
}

public sealed class CharacterRequirementsArgs(
    JobPrototype job,
    HumanoidCharacterProfile profile,
    IReadOnlyDictionary<string, TimeSpan> playTimes,
    bool whitelisted,
    int depth = 0,
    MindComponent? mind = null,
    IDependencyCollection? dependencies = null)
{
    public JobPrototype Job { get; set; } = job;
    public HumanoidCharacterProfile Profile { get; set; } = profile;
    public IReadOnlyDictionary<string, TimeSpan> PlayTimes { get; set; } = playTimes;
    public bool Whitelisted { get; set; } = whitelisted;
    public int Depth { get; set; } = depth;
    public MindComponent? Mind { get; set; } = mind;
    public IDependencyCollection? Dependencies { get; set; } = dependencies;

    public bool IsValid(CharacterRequirement requirement, IPrototype prototype,[NotNullWhen(false)] out string? reason)
    {
        Dependencies ??= IoCManager.Instance!;
        return requirement.IsValid(
            Job,
            Profile,
            PlayTimes,
            Whitelisted,
            prototype,
            Dependencies.Resolve<IEntityManager>(),
            Dependencies.Resolve<IPrototypeManager>(),
            Dependencies.Resolve<IConfigurationManager>(),
            out reason,
            Depth,
            Mind) && !requirement.Inverted;
    }
}
