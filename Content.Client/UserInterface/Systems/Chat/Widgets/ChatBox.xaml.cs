using Content.Client.UserInterface.Systems.Chat.Controls;
using Content.Shared._White;
using Content.Shared.Chat;
using Content.Shared.Input;
using Robust.Client.Audio;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Audio;
using Robust.Shared.Configuration;
using Robust.Shared.Input;
using Robust.Shared.Player;
using Robust.Shared.Utility;
using static Robust.Client.UserInterface.Controls.LineEdit;

namespace Content.Client.UserInterface.Systems.Chat.Widgets;

[GenerateTypedNameReferences]
#pragma warning disable RA0003
public partial class ChatBox : UIWidget
#pragma warning restore RA0003
{
    private readonly ChatUIController _controller;
    private readonly IEntityManager _entManager;
    private readonly IConfigurationManager _cfg; // WD EDIT
    private readonly ILocalizationManager _loc; // WD EDIT

    public bool Main { get; set; }

    public ChatSelectChannel SelectedChannel => ChatInput.ChannelSelector.SelectedChannel;
    // WD EDIT START
    private int _chatStackAmount = 0;
    private List<ChatStackData> _chatStackList;
    // WD EDIT END

    public ChatBox()
    {
        RobustXamlLoader.Load(this);
        _loc = IoCManager.Resolve<ILocalizationManager>();
        _entManager = IoCManager.Resolve<IEntityManager>();

        ChatInput.Input.OnTextEntered += OnTextEntered;
        ChatInput.Input.OnKeyBindDown += OnInputKeyBindDown;
        ChatInput.Input.OnTextChanged += OnTextChanged;
        ChatInput.ChannelSelector.OnChannelSelect += OnChannelSelect;
        ChatInput.FilterButton.Popup.OnChannelFilter += OnChannelFilter;

        _controller = UserInterfaceManager.GetUIController<ChatUIController>();
        _controller.MessageAdded += OnMessageAdded;
        _controller.RegisterChat(this);

        // WD EDIT START
        _cfg = IoCManager.Resolve<IConfigurationManager>(); 
        _chatStackAmount = _cfg.GetCVar(WhiteCVars.ChatStackAmount);
        if(_chatStackAmount < 0) // because someone would invariably try that
            _chatStackAmount = 0;
        _chatStackList = new(_chatStackAmount);
        _cfg.OnValueChanged(WhiteCVars.ChatStackAmount, UpdateChatStack, false); // i am uncomfortable calling repopulate on chatbox in its ctor, even though it worked in testing i'll still err on the side of caution
        // WD EDIT END
    }

    // WD EDIT START
    private void UpdateChatStack(int value)
    {
        _chatStackAmount = value >= 0 ? value : 0;
        Repopulate();
    } // WD EDIT END

    private void OnTextEntered(LineEditEventArgs args)
    {
        _controller.SendMessage(this, SelectedChannel);
    }

    private void OnMessageAdded(ChatMessage msg)
    {
        Logger.DebugS("chat", $"{msg.Channel}: {msg.Message}");
        if (!ChatInput.FilterButton.Popup.IsActive(msg.Channel))
        {
            return;
        }

        if (msg is { Read: false, AudioPath: { } })
            _entManager.System<AudioSystem>().PlayGlobal(msg.AudioPath, Filter.Local(), false, AudioParams.Default.WithVolume(msg.AudioVolume));

        msg.Read = true;

        var color = msg.MessageColorOverride ?? msg.Channel.TextColor();

        // WD EDIT START
        if(_chatStackAmount == 0)
        {
            AddLine(msg.WrappedMessage, color);
            return;
        }
        if (msg.IgnoreChatCoalescence)
        {
            AddLineAndShift(msg.WrappedMessage, color);
            return;
        }

        int index = _chatStackList.FindIndex(data => data.WrappedMessage == msg.WrappedMessage);

        if(index == -1)
        {
            AddLineAndShift(msg.WrappedMessage, color);
            return;
        }

        UpdateRepeatingLine(index);
    }

    private void AddLineAndShift(string wrappedMessage, Color color)
    {
        if (_chatStackList.Count == _chatStackList.Capacity)
            _chatStackList.RemoveAt(_chatStackList.Capacity - 1);

        _chatStackList.Insert(0, new ChatStackData(wrappedMessage, color));
        AddLine(wrappedMessage, color);
    }

    /// <summary>
    /// Removing and then adding insantly nudges the chat window up before slowly dragging it back down, which makes the whole chat log shake
    /// and make it borderline unreadable with frequent enough spam.
    /// Adding first and then removing does not produce any visual effects.
    /// The other option is to copypaste into Content all of OutputPanel and everything it uses but is intertanl to Robust namespace.
    /// Thanks robustengine, very cool.
    /// </summary>
    /// <remarks>
    /// zero index is the very last line, 1 is the line before the last one, 2 is the line before that, etc.
    /// </remarks>
    private void UpdateRepeatingLine(int index)
    {
        _chatStackList[index].RepeatCount++;
        for(int i = index; i >= 0; i--)
        {
            var data = _chatStackList[i];
            AddLine(data.WrappedMessage, data.ColorOverride, data.RepeatCount);
        }
        for (int i = index; i >= 0; i--) // same cycle for clarity, i doesn't actually matter here
        {
            Contents.RemoveEntry(Index.FromEnd(index + 2));
        }
    }
// WD EDIT END

private void OnChannelSelect(ChatSelectChannel channel)
    {
        _controller.UpdateSelectedChannel(this);
    }

    public void Repopulate()
    {
        Contents.Clear();
        _chatStackList = new List<ChatStackData>(_chatStackAmount);
        foreach (var message in _controller.History)
        {
            OnMessageAdded(message.Item2);
        }
    }

    private void OnChannelFilter(ChatChannel channel, bool active)
    {
        Contents.Clear();

        foreach (var message in _controller.History)
        {
            OnMessageAdded(message.Item2);
        }

        if (active)
        {
            _controller.ClearUnfilteredUnreads(channel);
        }
    }

    public void AddLine(string message, Color color, int repeat = 0) // WD EDIT
    {
        var formatted = new FormattedMessage(4); // WD EDIT // specifying size beforehand smells like a useless microoptimisation, but i'll give them the benefit of doubt
        formatted.PushColor(color);
        formatted.AddMarkup(message);
        formatted.Pop();
        if(repeat != 0) // WD EDIT START
        {   
            int displayRepeat = repeat + 1;
            int sizeIncrease = Math.Min(displayRepeat / 6, 5);
            formatted.AddMarkup(_loc.GetString("chat-system-repeated-message-counter",
                                ("count", displayRepeat),
                                ("size", 8+sizeIncrease)
                                ));
        } // WD EDIT END
        Contents.AddMessage(formatted);
    }

    public void Focus(ChatSelectChannel? channel = null)
    {
        var input = ChatInput.Input;
        var selectStart = Index.End;

        if (channel != null)
            ChatInput.ChannelSelector.Select(channel.Value);

        input.IgnoreNext = true;
        input.GrabKeyboardFocus();

        input.CursorPosition = input.Text.Length;
        input.SelectionStart = selectStart.GetOffset(input.Text.Length);
    }

    public void CycleChatChannel(bool forward)
    {
        var idx = Array.IndexOf(ChannelSelectorPopup.ChannelSelectorOrder, SelectedChannel);
        do
        {
            // go over every channel until we find one we can actually select.
            idx += forward ? 1 : -1;
            idx = MathHelper.Mod(idx, ChannelSelectorPopup.ChannelSelectorOrder.Length);
        } while ((_controller.SelectableChannels & ChannelSelectorPopup.ChannelSelectorOrder[idx]) == 0);

        SafelySelectChannel(ChannelSelectorPopup.ChannelSelectorOrder[idx]);
    }

    public void SafelySelectChannel(ChatSelectChannel toSelect)
    {
        toSelect = _controller.MapLocalIfGhost(toSelect);
        if ((_controller.SelectableChannels & toSelect) == 0)
            return;

        ChatInput.ChannelSelector.Select(toSelect);
    }

    private void OnInputKeyBindDown(GUIBoundKeyEventArgs args)
    {
        if (args.Function == EngineKeyFunctions.TextReleaseFocus)
        {
            ChatInput.Input.ReleaseKeyboardFocus();
            ChatInput.Input.Clear();
            args.Handle();
            return;
        }

        if (args.Function == ContentKeyFunctions.CycleChatChannelForward)
        {
            CycleChatChannel(true);
            args.Handle();
            return;
        }

        if (args.Function == ContentKeyFunctions.CycleChatChannelBackward)
        {
            CycleChatChannel(false);
            args.Handle();
        }
    }

    private void OnTextChanged(LineEditEventArgs args)
    {
        // Update channel select button to correct channel if we have a prefix.
        _controller.UpdateSelectedChannel(this);

        // Warn typing indicator about change
        _controller.NotifyChatTextChange();
    }

    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);

        if (!disposing) return;
        _controller.UnregisterChat(this);
        ChatInput.Input.OnTextEntered -= OnTextEntered;
        ChatInput.Input.OnKeyBindDown -= OnInputKeyBindDown;
        ChatInput.Input.OnTextChanged -= OnTextChanged;
        ChatInput.ChannelSelector.OnChannelSelect -= OnChannelSelect;
        _cfg.UnsubValueChanged(WhiteCVars.ChatStackAmount, UpdateChatStack); // WD EDIT
    }

    private class ChatStackData
    {
        public string WrappedMessage;
        public Color ColorOverride;
        public int RepeatCount = 0;

        public ChatStackData(string wrappedMessage, Color colorOverride)
        {
            WrappedMessage = wrappedMessage;
            ColorOverride = colorOverride;
        }
    }
}
